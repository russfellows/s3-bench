# v0.5.6 Release Summary: Cloud Storage Eventual Consistency Support

**Release Date**: October 7, 2025  
**Type**: Bug Fix + Feature Enhancement  
**Priority**: High (Critical for cloud storage benchmarking)

## Overview

Version 0.5.6 addresses a critical issue with cloud storage benchmarking and provides professional tooling for handling eventual consistency in distributed storage systems.

## The Problem

When benchmarking cloud storage (GCS, S3, Azure), the prepare phase could create objects extremely fast (>300 objects/sec using parallel execution). However, due to eventual consistency in cloud storage:

1. Objects were created successfully
2. Workload started immediately after prepare completed
3. GET operations failed with 404 errors because objects weren't yet propagated
4. Benchmark failed with: `Failed to get object from URI: gs://bucket/prepared-00000117.dat`

This made cloud storage benchmarking unreliable and required manual workarounds.

## The Solution

### 1. Configurable Post-Prepare Delay

Added `post_prepare_delay` field to YAML configuration:

```yaml
prepare:
  post_prepare_delay: 5  # Wait 5 seconds after creating objects
  ensure_objects:
    - base_uri: "gs://bucket/data/"
      count: 200
      object_size: 1048576
```

**Smart Behavior**:
- Only delays if new objects were created
- No delay if all objects already existed (reusing from previous run)
- User has full control via YAML (not hardcoded)

**Recommended Values**:
- Local storage (`file://`, `direct://`): 0 seconds (default, no delay)
- Cloud storage (S3, GCS, Azure): 2-5 seconds
- Large object counts (>1000): 5-10 seconds

### 2. Manual Phase Execution

Added CLI flags for professional multi-phase workflows:

#### `--verify` Flag
Verify that prepared objects exist and are accessible:

```bash
# After prepare, verify all objects are readable
sai3-bench run --config test.yaml --verify
```

**Output**:
```
=== Verification Phase ===
Verifying objects at gs://bucket/data/
✓ 200/200 objects verified and accessible at gs://bucket/data/

Verification complete: all prepared objects are accessible
```

**Failure Example**:
```
Verifying objects at gs://bucket/data/
Inaccessible objects:
  ✗ gs://bucket/data/prepared-00000117.dat: 404 Not Found
  ✗ gs://bucket/data/prepared-00000118.dat: 404 Not Found

Error: Verification failed: 198/200 objects accessible
```

#### `--skip-prepare` Flag
Skip prepare phase, assume objects already exist:

```bash
# First run: create objects
sai3-bench run --config test.yaml --no-cleanup

# Subsequent runs: reuse existing objects
sai3-bench run --config test.yaml --skip-prepare
```

### 3. Complete Manual Workflow

For maximum control over timing and verification:

```bash
# Phase 1: Prepare objects
sai3-bench run --config test.yaml --prepare-only
# Output: "Prepare-only mode: 200 objects created, exiting"

# Phase 2: Wait for propagation (user controls timing)
echo "Waiting for cloud storage propagation..."
sleep 60  # Wait 1 minute

# Phase 3: Verify all objects are accessible
sai3-bench run --config test.yaml --verify
# Output: "✓ 200/200 objects verified and accessible"

# Phase 4: Run benchmark (skip prepare since objects exist)
sai3-bench run --config test.yaml --skip-prepare
# Workload runs with pre-existing objects
```

## Technical Implementation

### Code Changes

**`src/config.rs`**:
- Added `post_prepare_delay: u64` to `PrepareConfig`
- Default: 0 (no delay)
- Documented with recommendations

**`src/main.rs`**:
- Added `--verify` flag for verification-only mode
- Added `--skip-prepare` flag to skip prepare phase
- Updated `run_workload()` to use configurable delay from YAML
- Added flag conflict validation

**`src/workload.rs`**:
- Added `verify_prepared_objects()` function
- Lists all prepared objects and attempts to stat each one
- Progress bar shows verification status
- Reports accessible/inaccessible count

### Verification Logic

```rust
pub async fn verify_prepared_objects(config: &PrepareConfig) -> Result<()> {
    for spec in &config.ensure_objects {
        // 1. List objects
        let existing = store.list(&spec.base_uri, true).await?;
        
        // 2. Check count
        if existing.len() < spec.count {
            bail!("Found {} but expected {}", existing.len(), spec.count);
        }
        
        // 3. Verify each object is accessible
        for uri in existing {
            stat_object_multi_backend(uri).await?;
        }
    }
    Ok(())
}
```

## Examples

### Example 1: Automatic Delay (Recommended)

```yaml
# examples/cloud-storage-with-delay.yaml
target: "gs://my-bucket/bench/"

prepare:
  post_prepare_delay: 3  # Wait 3 seconds after creating objects
  ensure_objects:
    - base_uri: "gs://my-bucket/bench/data/"
      count: 500
      object_size: 1048576

workload:
  - op: get
    path: "data/prepared-*.dat"
    weight: 100
```

**Usage**:
```bash
sai3-bench run --config cloud-storage-with-delay.yaml
```

**Output**:
```
=== Prepare Phase ===
Prepared 500 objects
Waiting 3s for object propagation (configured delay)...

=== Test Phase ===
Starting execution (60s duration, 32 concurrent workers)...
```

### Example 2: Manual Phased Execution

```bash
# Prepare
sai3-bench run --config cloud-storage-with-delay.yaml --prepare-only

# Wait (user control)
echo "Waiting 2 minutes for full propagation..."
sleep 120

# Verify
sai3-bench run --config cloud-storage-with-delay.yaml --verify

# Run benchmark
sai3-bench run --config cloud-storage-with-delay.yaml --skip-prepare
```

### Example 3: Repeated Runs Without Re-Prepare

```bash
# First run: prepare and keep objects
sai3-bench run --config test.yaml --no-cleanup

# Second run: skip prepare, reuse objects
sai3-bench run --config test.yaml --skip-prepare --no-cleanup

# Third run: still reusing objects
sai3-bench run --config test.yaml --skip-prepare --no-cleanup

# Final run: cleanup after
sai3-bench run --config test.yaml --skip-prepare
```

## Migration Guide

### For Local Storage (No Changes Needed)

```yaml
# file:// and direct:// - works as before
prepare:
  ensure_objects:
    - base_uri: "file:///tmp/test/"
      count: 100
# Default post_prepare_delay: 0 (no delay)
```

### For Cloud Storage (Add Delay)

**Before (v0.5.5 - could fail with 404)**:
```yaml
prepare:
  ensure_objects:
    - base_uri: "gs://bucket/data/"
      count: 200
```

**After (v0.5.6 - reliable)**:
```yaml
prepare:
  post_prepare_delay: 3  # Add this line
  ensure_objects:
    - base_uri: "gs://bucket/data/"
      count: 200
```

## Performance Impact

- **Prepare speed**: Unchanged (still >300 objects/sec)
- **Additional delay**: User-configurable (default: 0)
- **Verification overhead**: ~1-2 seconds per 100 objects (sequential stat operations)

## Compatibility

- **Backward compatible**: All existing configs work (default delay is 0)
- **New field optional**: `post_prepare_delay` defaults to 0 if omitted
- **No breaking changes**: Existing workflows unchanged

## Files Changed

```
Modified:
  src/config.rs         - Added post_prepare_delay field
  src/main.rs           - Added --verify and --skip-prepare flags
  src/workload.rs       - Added verify_prepared_objects() function
  docs/CHANGELOG.md     - Complete v0.5.6 documentation
  docs/CONFIG_SYNTAX.md - Documented post_prepare_delay
  Cargo.toml            - Version bump to 0.5.6

Added:
  examples/cloud-storage-with-delay.yaml - Complete example
  docs/V0.5.6_RELEASE_SUMMARY.md        - This file
```

## Testing

Tested on:
- ✅ Google Cloud Storage (GCS) with 200 objects
- ✅ Local file:// storage (no delay needed)
- ✅ Verification with accessible objects
- ✅ Verification failure detection (inaccessible objects)
- ✅ Manual phased workflow
- ✅ Repeated runs with --skip-prepare

## Next Steps

Users should:
1. Update configs to add `post_prepare_delay` for cloud storage
2. Test with `--verify` flag to ensure proper propagation delay
3. Use manual phased execution for production benchmarks
4. Report any remaining 404 issues (may need longer delays)

## Conclusion

Version 0.5.6 provides professional-grade tooling for handling eventual consistency in cloud storage benchmarking. The combination of configurable delays, verification phase, and manual workflow control gives users complete flexibility while maintaining backward compatibility.
