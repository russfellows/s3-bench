# io-bench v0.5.3 Enhancement Plan

**Date**: October 4, 2025  
**Status**: Planning Phase  
**Goal**: Surpass warp/warp-replay with realistic object size distributions and enhanced configurability

---

## Executive Summary

v0.5.2 achieved **parity** with MinIO warp/warp-replay. Version 0.5.3 will **surpass** it by adding:

1. **Realistic size distributions** (uniform, lognormal) vs warp's simplistic "random"
2. **Per-operation concurrency** for advanced workload shaping
3. **Enhanced documentation** with N↔N remapping examples and prepare profiles
4. **Improved configurability** for real-world testing scenarios

---

## Enhancement Areas

### 1. Object Size Distributions (HIGH PRIORITY)

**Current State**: 
- Fixed `object_size` per PUT operation in YAML
- Prepare step uses uniform random: `rand::rng().random_range(min_size..=max_size)`
- No distribution control for realistic workloads

**Problem**: 
- Warp's "random" distribution is unrealistic
- Real-world object storage shows **lognormal** distribution (many small files, few large ones)
- Can't model realistic workload patterns

**Solution**: Add `size_distribution` field to PUT operations and PrepareConfig

#### Implementation Plan

**A. Config Schema Changes** (`src/config.rs`)

```yaml
# New YAML syntax examples:

# 1. Fixed size (current behavior - unchanged)
- op: put
  path: "data/"
  object_size: 1048576  # 1 MB fixed

# 2. Uniform distribution (evenly distributed sizes)
- op: put
  path: "data/"
  size_distribution:
    type: uniform
    min: 1024        # 1 KB
    max: 10485760    # 10 MB

# 3. Lognormal distribution (realistic - many small, few large)
- op: put
  path: "data/"
  size_distribution:
    type: lognormal
    mean: 1048576    # Mean size 1 MB
    std_dev: 2097152 # Std deviation 2 MB
    min: 1024        # Floor
    max: 107374182   # Ceiling (100 MB)
```

**B. Code Changes**

1. **Config structures** (`src/config.rs`):
   ```rust
   #[derive(Debug, Deserialize, Clone)]
   pub enum SizeSpec {
       Fixed(u64),
       Distribution(SizeDistribution),
   }
   
   #[derive(Debug, Deserialize, Clone)]
   pub struct SizeDistribution {
       #[serde(rename = "type")]
       pub dist_type: DistributionType,
       pub min: Option<u64>,
       pub max: Option<u64>,
       #[serde(flatten)]
       pub params: DistributionParams,
   }
   
   #[derive(Debug, Deserialize, Clone)]
   #[serde(tag = "type", rename_all = "lowercase")]
   pub enum DistributionType {
       Uniform,
       Lognormal,
   }
   
   #[derive(Debug, Deserialize, Clone)]
   pub struct DistributionParams {
       // For lognormal
       pub mean: Option<u64>,
       pub std_dev: Option<u64>,
   }
   ```

2. **Size generator module** (`src/size_generator.rs` - NEW):
   ```rust
   use rand_distr::{Distribution, Uniform, LogNormal};
   
   pub struct SizeGenerator {
       generator: SizeGeneratorImpl,
   }
   
   enum SizeGeneratorImpl {
       Fixed(u64),
       Uniform { dist: Uniform<u64>, min: u64, max: u64 },
       LogNormal { dist: LogNormal<f64>, min: u64, max: u64 },
   }
   
   impl SizeGenerator {
       pub fn new(spec: &SizeSpec) -> Result<Self> { ... }
       pub fn generate(&self) -> u64 { ... }
   }
   ```

3. **Update OpSpec** (`src/config.rs`):
   ```rust
   Put {
       path: String,
       #[serde(flatten)]
       size_spec: SizeSpec,  // Replaces object_size
   }
   ```

4. **Update PrepareConfig** (`src/config.rs`):
   ```rust
   pub struct EnsureSpec {
       pub base_uri: String,
       pub count: u64,
       
       // OLD: min_size, max_size (deprecated but keep for backward compat)
       #[serde(default)]
       pub min_size: Option<u64>,
       #[serde(default)]
       pub max_size: Option<u64>,
       
       // NEW: size_distribution (preferred)
       #[serde(default)]
       pub size_distribution: Option<SizeDistribution>,
       
       pub fill: FillPattern,
   }
   ```

**C. Backward Compatibility**

- Support old `object_size: N` syntax → converts to `SizeSpec::Fixed(N)`
- Support old `min_size`/`max_size` in prepare → converts to `uniform` distribution
- Add deprecation warnings for old syntax in logs

**D. Testing**

- Unit tests for SizeGenerator with all distribution types
- Integration test config: `tests/configs/size_distributions_test.yaml`
- Validate lognormal produces expected distribution (histogram verification)

---

### 2. Per-Operation Concurrency (MEDIUM PRIORITY)

**Current State**:
- Global `concurrency: N` applies to all operations
- Can't have 64 GET workers but 8 PUT workers

**Solution**: Optional per-operation concurrency override

#### Implementation Plan

**A. Config Schema Changes**

```yaml
# Global default
concurrency: 32

workload:
  # Override for specific operation
  - op: get
    path: "data/*"
    weight: 70
    concurrency: 64  # NEW: Override global setting
  
  - op: put
    path: "data/"
    object_size: 1048576
    weight: 30
    concurrency: 8   # NEW: Lower concurrency for PUTs
```

**B. Code Changes**

1. **Add concurrency field to WeightedOp** (`src/config.rs`):
   ```rust
   #[derive(Debug, Deserialize, Clone)]
   pub struct WeightedOp {
       pub weight: u32,
       #[serde(default)]
       pub concurrency: Option<usize>,  // NEW: Override global
       #[serde(flatten)]
       pub spec: OpSpec,
   }
   ```

2. **Update workload executor** (`src/workload.rs`):
   ```rust
   // In run_workload_timed:
   let op_concurrency = weighted_op.concurrency.unwrap_or(config.concurrency);
   let sem = Arc::new(Semaphore::new(op_concurrency));
   ```

**C. Documentation**

- Add example to `docs/CONFIG.sample.yaml`
- Document in README under "Advanced Features"
- Note: Useful for skewing GET vs PUT worker pools

---

### 3. Enhanced Documentation (HIGH PRIORITY)

**A. N↔N Remapping Example**

Add to README.md under "Replay & Remapping" section:

```yaml
# Example: Map 3 source buckets to 2 destination buckets
# (Many-to-many remapping)

remap:
  # Source bucket 1 & 2 → Destination bucket A
  - pattern: "s3://source-1/(.+)"
    replacement: "s3://dest-a/$1"
  - pattern: "s3://source-2/(.+)"
    replacement: "s3://dest-a/$1"
  
  # Source bucket 3 → Destination bucket B
  - pattern: "s3://source-3/(.+)"
    replacement: "s3://dest-b/$1"
```

**B. Prepare Profiles Documentation**

Add to `docs/CONFIG.sample.yaml`:

```yaml
# Prepare Profile 1: Multi-size testing (S3 realistic workload)
prepare:
  ensure_objects:
    # Small objects (typical metadata, thumbnails)
    - base_uri: "s3://bucket/small/"
      count: 10000
      size_distribution:
        type: lognormal
        mean: 4096
        std_dev: 2048
        min: 1024
        max: 65536
      fill: random
    
    # Medium objects (documents, images)
    - base_uri: "s3://bucket/medium/"
      count: 1000
      size_distribution:
        type: lognormal
        mean: 1048576      # 1 MB
        std_dev: 524288    # 512 KB
        min: 65536         # 64 KB
        max: 10485760      # 10 MB
      fill: zero
    
    # Large objects (videos, backups)
    - base_uri: "s3://bucket/large/"
      count: 100
      size_distribution:
        type: uniform
        min: 10485760      # 10 MB
        max: 104857600     # 100 MB
      fill: zero
  
  cleanup: false  # Keep objects for repeated testing

# Prepare Profile 2: Warp-compatible uniform testing
prepare:
  ensure_objects:
    - base_uri: "s3://bucket/test/"
      count: 5000
      min_size: 1048576   # Old syntax still works
      max_size: 1048576   # Creates uniform 1 MB objects
      fill: zero
```

**C. Distribution Documentation**

Add new section to README:

```markdown
### Object Size Distributions

io-bench supports realistic size distributions for PUT operations and prepare steps:

#### Fixed Size
```yaml
object_size: 1048576  # All objects exactly 1 MB
```

#### Uniform Distribution
Evenly distributed sizes across a range:
```yaml
size_distribution:
  type: uniform
  min: 1024
  max: 10485760
```

#### Lognormal Distribution (Recommended for Realism)
Models real-world storage: many small files, few large ones.
```yaml
size_distribution:
  type: lognormal
  mean: 1048576      # Mean size
  std_dev: 2097152   # Standard deviation
  min: 1024          # Floor (reject values below)
  max: 107374182     # Ceiling (reject values above)
```

**Why lognormal?** Research shows object storage workloads follow lognormal 
distributions naturally - users create many small files (configs, thumbnails, 
metadata) and few large files (videos, backups). This is more realistic than 
warp's simple random distribution.
```

---

### 4. Key Popularity / Access Patterns (FUTURE - v0.6.0)

**Out of scope for v0.5.3**, but document for future:

- Zipf distribution for GET operations (80/20 rule - 20% of objects get 80% of requests)
- Hotspot modeling (temporal locality)
- Age-based access patterns (newer objects accessed more)

Add note in README: "Key popularity distributions planned for v0.6.0"

---

## Implementation Order

### Phase 1: Core Distribution Support (2-3 hours)
1. ✅ Create `src/size_generator.rs` module
2. ✅ Update `src/config.rs` with new types
3. ✅ Add backward compatibility layer
4. ✅ Update `src/workload.rs` prepare_objects to use SizeGenerator
5. ✅ Unit tests for SizeGenerator

### Phase 2: Workload Integration (1-2 hours)
1. ✅ Update PUT operation to use SizeGenerator
2. ✅ Update workload executor
3. ✅ Integration test with all distribution types

### Phase 3: Per-Op Concurrency (1 hour)
1. ✅ Add concurrency field to WeightedOp
2. ✅ Update workload executor
3. ✅ Test with mixed concurrency config

### Phase 4: Documentation (2 hours)
1. ✅ Update README with distributions section
2. ✅ Add N↔N remapping example
3. ✅ Create prepare profiles in CONFIG.sample.yaml
4. ✅ Update CHANGELOG

### Phase 5: Testing & Polish (1 hour)
1. ✅ Create comprehensive test configs
2. ✅ Run full test suite
3. ✅ Update version to 0.5.3
4. ✅ Update badges and docs

**Total Estimated Time**: 7-9 hours

---

## Success Criteria

- [ ] Lognormal distribution generates realistic size patterns
- [ ] Uniform distribution works correctly with min/max bounds
- [ ] Backward compatibility: old configs still work
- [ ] Per-operation concurrency overrides global setting
- [ ] Documentation includes N↔N remapping example
- [ ] Prepare profiles documented with realistic scenarios
- [ ] All tests pass (unit + integration)
- [ ] Performance: no regression vs v0.5.2

---

## Testing Strategy

### Unit Tests
- `size_generator.rs`: Test each distribution type
- Verify lognormal respects min/max bounds
- Verify uniform produces even distribution

### Integration Tests
- `tests/configs/lognormal_test.yaml` - Lognormal PUT workload
- `tests/configs/mixed_concurrency_test.yaml` - Per-op concurrency
- `tests/configs/prepare_profiles_test.yaml` - Multi-size prepare

### Performance Tests
- Compare v0.5.3 vs v0.5.2 throughput (should be equal)
- Verify size generation doesn't add measurable latency

---

## Migration Notes

### For Users

**Old syntax still works**:
```yaml
- op: put
  path: "data/"
  object_size: 1048576  # ✅ Still supported
```

**New recommended syntax**:
```yaml
- op: put
  path: "data/"
  size_distribution:
    type: lognormal
    mean: 1048576
    std_dev: 524288
    min: 1024
    max: 10485760
```

**Prepare step migration**:
```yaml
# Old (still works)
prepare:
  ensure_objects:
    - base_uri: "s3://bucket/"
      count: 1000
      min_size: 1048576
      max_size: 1048576

# New (preferred)
prepare:
  ensure_objects:
    - base_uri: "s3://bucket/"
      count: 1000
      size_distribution:
        type: uniform
        min: 1048576
        max: 10485760
```

---

## Competitive Advantage vs Warp

| Feature | Warp | io-bench v0.5.3 |
|---------|------|-----------------|
| Size distributions | Random only | Uniform + Lognormal (realistic) |
| Concurrency control | Global only | Per-operation override |
| Prepare profiles | Basic | Documented patterns with realistic distributions |
| Backend support | S3 only | 5 backends (S3, Azure, GCS, File, Direct I/O) |
| Remapping | 1:1 only | 1:1, 1→N, N→1, N↔N (regex) |
| Output format | Text analysis | TSV (13 columns, machine-readable) |
| Memory usage | High (replay) | Constant (streaming replay) |

---

## References

- **Lognormal distribution research**: Multiple studies show object storage follows lognormal patterns
- **Warp comparison**: https://github.com/minio/warp
- **rand_distr crate**: https://docs.rs/rand_distr/latest/rand_distr/

---

## Next Steps (After Review)

1. Review plan with user
2. Get approval for scope and approach
3. Begin Phase 1 implementation
4. Iterate based on testing results

**Status**: Awaiting approval to proceed ✋
